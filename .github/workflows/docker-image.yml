name: Deploy Infrastructure and Application

on:
  push:
    branches: [ "main" ]
  workflow_dispatch: # Allows manual trigger

jobs:
  deploy:
    name: Deploy Infra & App
    runs-on: ubuntu-latest
    # Optional: Link to GitHub Environment for secrets/protection rules
    # environment: production

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      # Fetch all history so we can compare commits if needed by changed-files action
      with:
        fetch-depth: 0

    # --- Determine Changed Files ---
    # This action checks which files changed compared to the previous commit on the branch
    - name: Get changed files
      id: changed-files
      uses: tj-actions/changed-files@v44 # Using a popular action for this
      with:
        # List all file patterns that should trigger a build/deployment
        # Be specific to avoid unnecessary runs
        files: |
          terraform-phase1/**.tf
          backend/**
          frontend/**
          docker-compose.yaml
          **/Dockerfile*
          .github/workflows/docker-image.yml

    # --- Terraform Steps ---
    - name: Configure AWS credentials
      # Use credentials with permissions for both Terraform apply and ECR push
      # Or use separate steps with different credentials and conditions
      id: configure-aws-creds
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }} # Combined TF & ECR Key
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }} # Combined TF & ECR Key
        aws-region: ca-central-1 # Your AWS region

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3

    - name: Terraform Init
      id: init
      run: |
        cd ./terraform-phase1
        terraform init \
          -backend-config="bucket=capstonebucketcloud2025" \
          -backend-config="key=production/terraform.tfstate" \
          -backend-config="region=ca-central-1"
        cd ..
      shell: bash

    # Conditionally Apply Terraform ONLY if .tf files changed
    - name: Terraform Apply (if TF files changed)
      id: apply
      # This checks if any file within the 'terraform-phase1/' directory triggered the 'changed-files' step
      if: steps.changed-files.outputs.any_changed == 'true' && contains(steps.changed-files.outputs.all_changed_files, 'terraform-phase1/')
      run: |
        cd ./terraform-phase1
        terraform apply -auto-approve -no-color
        # Verify the apply was successful
        if [ $? -ne 0 ]; then
          echo "Terraform apply failed"
          exit 1
        fi
        cd ..
      shell: bash

    # Force Terraform Apply on manual trigger
    - name: Force Terraform Apply (on manual trigger)
      id: force-apply
      if: github.event_name == 'workflow_dispatch'
      run: |
        cd ./terraform-phase1
        terraform apply -auto-approve -no-color
        # Verify the apply was successful
        if [ $? -ne 0 ]; then
          echo "Terraform apply failed"
          exit 1
        fi
        cd ..
      shell: bash

    # Always Apply Terraform on first run
    - name: Always Apply Terraform (on first run)
      id: first-run-apply
      if: steps.changed-files.outputs.any_changed == 'false' && github.event_name == 'workflow_dispatch'
      run: |
        cd ./terraform-phase1
        terraform apply -auto-approve -no-color
        # Verify the apply was successful
        if [ $? -ne 0 ]; then
          echo "Terraform apply failed"
          exit 1
        fi
        cd ..
      shell: bash

    # Always Get Terraform Outputs (reads from the state file)
    - name: Get Terraform Outputs
      id: tf_output
      # Run this step always *after* init (and potentially apply)
      # to get the current values from the state file
      run: |
        cd ./terraform-phase1
        
        # Check if outputs exist before trying to read them
        if terraform output -json | grep -q "frontend_alb_dns"; then
          frontend_dns=$(terraform output -raw frontend_alb_dns)
          echo "TF_FRONTEND_ALB_DNS=$frontend_dns" >> $GITHUB_ENV
          echo "Frontend ALB DNS: $frontend_dns"
        else
          echo "Warning: frontend_alb_dns output not found in Terraform state"
          echo "TF_FRONTEND_ALB_DNS=placeholder" >> $GITHUB_ENV
        fi
        
        if terraform output -json | grep -q "backend_alb_dns"; then
          backend_dns=$(terraform output -raw backend_alb_dns)
          echo "TF_BACKEND_ALB_DNS=$backend_dns" >> $GITHUB_ENV
          echo "Backend ALB DNS: $backend_dns"
        else
          echo "Warning: backend_alb_dns output not found in Terraform state"
          echo "TF_BACKEND_ALB_DNS=placeholder" >> $GITHUB_ENV
        fi
        
        cd ..
      shell: bash

    # --- Docker Steps ---
    # Set the image tag to the commit SHA for better tracking
    - name: Set Docker Image Tag
      run: |
        echo "IMAGE_TAG=${{ github.sha }}" >> $GITHUB_ENV
        echo "Using image tag: ${{ github.sha }}"
      shell: bash

    # Install Docker Compose
    - name: Install Docker Compose
      run: |
        # Add Docker's official GPG key
        sudo apt-get update
        sudo apt-get install -y ca-certificates curl gnupg
        sudo install -m 0755 -d /etc/apt/keyrings
        curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
        sudo chmod a+r /etc/apt/keyrings/docker.gpg

        # Add the repository to Apt sources
        echo \
          "deb [arch="$(dpkg --print-architecture)" signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
          "$(. /etc/os-release && echo "$VERSION_CODENAME")" stable" | \
          sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

        # Update package index and install Docker Compose
        sudo apt-get update
        sudo apt-get install -y docker-compose-plugin
        docker compose version
      shell: bash

    # Condition: Run if *any* monitored files changed (TF, app, Dockerfile, etc.)
    - name: Set up Docker Buildx
      if: steps.changed-files.outputs.any_changed == 'true'
      uses: docker/setup-buildx-action@v3

    - name: Log in to Amazon ECR
      if: steps.changed-files.outputs.any_changed == 'true'
      # Uses credentials configured in the 'configure-aws-creds' step
      uses: aws-actions/amazon-ecr-login@v2

    - name: Create .env file for Docker Build
      if: steps.changed-files.outputs.any_changed == 'true'
      run: |
        # Use outputs retrieved from TF state (available via GITHUB_ENV)
        echo "FRONTEND_ALB_DNS=${{ env.TF_FRONTEND_ALB_DNS }}" >> .env
        echo "BACKEND_ALB_DNS=${{ env.TF_BACKEND_ALB_DNS }}" >> .env

        # Use SECRETS for sensitive data
        echo "BACKEND_PORT=${{ secrets.BACKEND_PORT }}" >> .env
        echo "MONGODB_URI=${{ secrets.MONGODB_URI }}" >> .env
        echo "JWT_SECRET=${{ secrets.JWT_SECRET }}" >> .env
        echo "CLOUDINARY_CLOUD_NAME=${{ secrets.CLOUDINARY_CLOUD_NAME }}" >> .env
        echo "CLOUDINARY_API_KEY=${{ secrets.CLOUDINARY_API_KEY }}" >> .env
        echo "CLOUDINARY_API_SECRET=${{ secrets.CLOUDINARY_API_SECRET }}" >> .env
        echo "UPSTASH_REDIS_URL=${{ secrets.UPSTASH_REDIS_URL }}" >> .env
      shell: bash

    # Build and push the frontend image
    - name: Build and Push Frontend Image
      if: steps.changed-files.outputs.any_changed == 'true' && contains(steps.changed-files.outputs.all_changed_files, 'frontend/')
      run: |
        cd frontend
        docker compose -f docker-compose.prod.yml build
        docker compose -f docker-compose.prod.yml push
        cd ..
      shell: bash

    # Build and push the backend image
    - name: Build and Push Backend Image
      if: steps.changed-files.outputs.any_changed == 'true' && contains(steps.changed-files.outputs.all_changed_files, 'backend/')
      run: |
        cd backend
        docker compose -f docker-compose.prod.yml build
        docker compose -f docker-compose.prod.yml push
        cd ..
      shell: bash
